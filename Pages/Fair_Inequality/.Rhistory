df %>% ivreg(formula = avgverb ~ classize + tipuach | pclassize)
# verify with ivreg
df %>% ivreg(avgverb ~ classize + tipuach | pclassize)
# verify with ivreg
ivreg(avgverb ~ classize + tipuach | pclassize, data = df)
# verify with ivreg
ivreg(avgverb ~ tipuach | classize | pclassize, data = df)
# verify with ivreg
ivreg(avgverb ~ tipuach | classize | pclassize, data = df) %>% summary()
library(dplyr)
library(tidyverse)
library(haven)
library(ggplot2)
library(ivreg)
df <- read_dta(file='G:/My Drive/Work/University/Year 3/ECON0021  Microeconometrics/Assignments/Assignment 1/final4.dta')
df %>% lm(formula = avgverb ~ classize) %>% summary()
# intercept: 68.37984 (0.85015)
# coefficient:
# classize: 0.13530 (0.02743)
### PART 1
# Question A: regress avgverb on classsize, then also on % disadvantaged students
df %>% lm(formula = avgverb ~ classize) %>% summary()
df %>% lm(formula = avgverb ~ classize + tipuach) %>% summary()
# Question C: first-stage regression with tipuach as control
df %>% lm(formula = classize ~ pclassize + tipuach) %>% summary()
df %>% lm(formula = classize ~ pclassize + tipuach) %>% summary()
# Question B: create the Maimonides rule and scatterplot it vs school size.
df$pclassize <- df$c_size / (as.integer((df$c_size - 1)/40) + 1)
df %>% ggplot() + geom_point(aes(x = c_size, y = pclassize))
df %>% ggplot() + geom_point(aes(x = c_size, y = classize))
df %>% ggplot() + geom_point(aes(x = classize, y = avgverb))
df %>% ggplot() + geom_point(aes(x = c_size, y = avgverb))
df %>% ggplot() + geom_point(aes(x = c_size, y = pclassize))
df %>% ggplot() + geom_point(aes(x = pclassize, y = avgverb))
df %>% ggplot() + geom_point(aes(x = c_size, y = pclassize))
# Question D: estimate reduced form equation with control tipuach, verify with ivreg
df %>% lm(formula = avgverb ~ pclassize + tipuach) %>% summary()
# Question D: estimate reduced form equation with control tipuach, verify with ivreg
df %>% lm(formula = classize ~ pclassize + tipuach) %>% summary()
# Question D: estimate reduced form equation with control tipuach, verify with ivreg
df %>% lm(formula = classize ~ pclassize + tipuach) %>% summary()
# Question D: estimate reduced form equation with control tipuach, verify with ivreg
df %>% lm(formula = avgverb ~ pclassize + tipuach) %>% summary()
# verify with ivreg
ivreg(avgverb ~ tipuach | classize | pclassize, data = df) %>% summary()
# Clean the environment
# ==========================================================================
rm(list = ls())
# ==========================================================================
# Import libraries
# ==========================================================================
#install.packages("tidyverse")
#install.packages("plm")
#install.packages("haven")
#install.packages("AER")
#install.packages("lmtest")
library(tidyverse)
# --------------------------------------------------------------------------
# The tidyverse package in a suite of packages that provide key functions
# for data transformation and use. The core packages included in tidyverse
# are ggplot2, tidyr, readr, dplyr, stringr, purrr, and forcats, although
# there are various additional packages that can be installed separately.
# --------------------------------------------------------------------------
library(haven)
# --------------------------------------------------------------------------
# Haven enables R to read and write various data formats used by other
# statistical packages by wrapping the fantastic ReadStat C library
# written by Evan Miller. Haven is part of the tidyverse.
# Currently it supports: SAS: read_sas() reads.
# Here, I use read_dta()
# --------------------------------------------------------------------------
library(plm)
# --------------------------------------------------------------------------
# plm is a package for R which intends to make the estimation of
# linear panel models straightforward. plm provides functions to
# estimate a wide variety of models and to make (robust) inference.
# --------------------------------------------------------------------------
library(stargazer)
# --------------------------------------------------------------------------
# stargazer is an R package that creates LATEX code, HTML code and ASCII text
# for well-formatted regression tables, with multiple models side-by-side,
# as well as for summary statistics tables, data frames, vectors and matrices.
# --------------------------------------------------------------------------
# ==========================================================================
# Set the paths
# ==========================================================================
toppath <- "C:/Users/rasmu/Desktop/R Session 1"
datapath <- paste0(toppath, "/Data", sep = "")
codepath <- paste0(toppath, "/Code", sep = "")
# ==========================================================================
# Import data
# ==========================================================================
file <- "/jtrain1.dta"
df <- read_dta(paste0(datapath, file, sep = ""))
df <- read_dta(paste0(datapath, file, sep = ""))
rm(list = ls())
library(tidyverse)
library(haven)
library(plm)
library(stargazer)
toppath <- "C:/Users/rasmu/Desktop/R Session 1"
datapath <- paste0(toppath, "/Data", sep = "")
codepath <- paste0(toppath, "/Code", sep = "")
# ==========================================================================
# Import data
# ==========================================================================
file <- "/jtrain1.dta"
df <- read_dta(paste0(datapath, file, sep = ""))
View(df)
# Pooled OLS
# Regressand lscrap: scraping rate
# Regressors:
lm(lscrap ~ d88 + d89 + grant + grant_1, data = df)
# Pooled OLS
# Regressand lscrap: scraping rate
# Regressors:
pooledols <- lm(lscrap ~ d88 + d89 + grant + grant_1, data = df)
summary(pooledols)
stargazer(pooledols)
res
res <- residuals(pooledols)
res
summary_reg <- summary(pooledols)
residuals <- residuals(pooledols) # Residuals per unit.
fitted_vals <- fitted(pooledols)
reg_coefs <- coef(pooledols)
reg_coefs
summary_reg
summary_reg
reg_alpha <- coef[1]
reg_beta <- coef[2]
reg_alpha <- reg_coefs[1]
reg_beta <- reg_coefs[2]
reg_r_squuared <- summary_reg$r.squared
reg_r_squuared
# Pooled OLS with interaction
pooledols_int <- lm(lscrap ~ d88 + d89 + grant + grant_1 + grant_1*d89, df)
summary(pooledols_int)
# SE's
pooledols_HAC_vcov <- sandwich::vcovHAC(pooledols) # Heteroskedasticity
pooledols_NW_vcov <- sandwich::NeweyWest(pooledols) # Newey-West, AC
pooledols_NW_ses <- sqrt(diag(pooledols_NW_vcov))
pooledols_NW_ses
stargazer(pooledols, pooledols, se=list(NULL, pooledols_NW_ses), column.labels= c("default", "robust"), align=TRUE)
data('murder')
install.packages('wooldridge')
data('murder')
library('wooldridge')
data('murder')
View(df)
View(df)
library(wooldridge)
library(tidyverse)
library(haven)
library(plm)
library(stargazer)
data('murder')
df <- data('murder')
## Question a: First differenced model
df
## Question a: First differenced model
df %>% summarise()
library(tidyverse)
## Question a: First differenced model
df %>% summarise()
## Question a: First differenced model
df %>% summarize()
## Question a: First differenced model
df %>% summarise()
## Question a: First differenced model
df %>% summarise(df)
## Question a: First differenced model
dfsummarise(df)
## Question a: First differenced model
summarise(df)
## Question a: First differenced model
summary(df)
library(wooldridge)
library(tidyverse)
library(haven)
library(plm)
library(stargazer)
df <- data('murder')
# Reg of interest: murder ~ time FE, execuctions, unemployment, county FE
# Raw model
## Question a: First differenced model
summary(df)
data('murder')
data('murder')
library(wooldridge)
data('murder')
library(wooldridge)
library(tidyverse)
library(haven)
library(plm)
library(stargazer)
data('murder')
load('murder')
library('wooldridge')
load('murder')
data(package='wooldridge')
load('murder')
data('murder')
data("murder")
library("wooldridge")
library(tidyverse)
library(haven)
library(plm)
library(stargazer)
data(package="wooldridge")
data("murder")
load("murder")
load("murder")
library(wooldridge)
data("wage1")
wageModel <- lm(lwage ~ educ + exper + tenure, data = wage1)
summary(wageModel)
library(wooldridge)
library(tidyverse)
library(haven)
library(plm)
library(stargazer)
data("murder")
# Reg of interest: murder ~ time FE, execuctions, unemployment, county FE
# Raw model
## Question a: First differenced model
summary(df)
data(package="wooldridge")
data("murder")
df <- data("murder")
df
library(wooldridge)
data("wage1")
wageModel <- lm(lwage ~ educ + exper + tenure, data = wage1)
summary(wageModel)
library(wooldridge)
data("murder")
wageModel <- lm(lwage ~ educ + exper + tenure, data = wage1)
summary(wageModel)
library(wooldridge)
data("murder")
wageModel <- lm(lwage ~ educ + exper + tenure, data = wage1)
summary(wageModel)
wageModel <- lm(lwage ~ educ + exper + tenure, data = murder)
data("murder")
data("murder")
library(wooldridge)
data("murder")
wageModel <- lm(lwage ~ educ + exper + tenure, data = murder)
summarise(murder)
df <- data.frame(data("murder"))
df <- get(data("murder"))
summary(df)
df %>% filter(year>87) %>% plm(mrdrte ~ exec + unem)
df %>% filter(year>87)
df %>% filter(year>87)  %>% plm(mrdrte ~ exec + unem, data=.)
df %>% filter(year>87)%>% plm(mrdrte ~ exec + unem, data=.)
df <- get(data("murder")) %>% filter(year > 87)
summary(df)
pooled_ols <- lm(mrdrte ~ exec + unem, data=df)
summary(pooled_ols)
pooled_ols <- plm(mrdrte ~ exec + unem, data=df)
pooled_ols <- lm(mrdrte ~ exec + unem, data=df)
summary(pooled_ols)
View(df)
View(df)
fd <- plm(mrdrte ~ exec + unem, data=pdf, model = "fd")
pdf <- pdata.frame(df, index= c("id", "year"))
df <- pdata.frame(df, index = )
fd <- plm(mrdrte ~ exec + unem, data=pdf, model = "fd")
summarise(fd)
View(pdf)
View(pdf)
fd <- plm(mrdrte ~ exec + unem, data=pdf, model = "within")
summarise(fd)
fd <- plm(mrdrte ~ exec + unem, data=df, model = "fd", index = c("id", "year"))
fd <- plm(mrdrte ~ exec + unem, effect = "individual", data=df, model = "fd", index = c("id", "year"))
library(wooldridge)
library(tidyverse)
library(haven)
library(plm)
library(stargazer)
data(package="wooldridge")
df <- get(data("murder")) %>% filter(year > 87)
summary(df)
pooled_ols <- lm(mrdrte ~ exec + unem, data=df)
summary(pooled_ols)
pdf <- pdata.frame(df, index = c("id", "year"))
df <- pdata.frame(df, index = )
fd <- plm(mrdrte ~ exec + unem, effect = "individual", data=df, model = "fd", index = c("id", "year"))
pdf <- pdata.frame(df, index = c("state", "year"))
df <- pdata.frame(df, index = )
fd <- plm(mrdrte ~ exec + unem, effect = "individual", data=df, model = "fd", index = c("id", "year"))
pdf <- pdata.frame(df, index = c("id", "year"))
library(wooldridge)
library(tidyverse)
library(haven)
library(plm)
library(stargazer)
df <- get(data("murder")) %>% filter(year > 87)
pdf <- pdata.frame(df, index = c("id", "year"))
df <- pdata.frame(df, index = )
firstdiff <- plm(lscrap ~ d88 + d89 + grant + grant_1, data = pdf, model = "fd")
firstdiff <- plm(mrdrte ~ exec + unem, data = pdf, model = "fd")
summarise(firstdiff)
install.packages("installr")
library(installr)
updateR()
install.packages("htmlwidgets")
install.packages("htmlwidgets")
library(data.table)
library(ggplot2)
knitr::opts_chunk$set(echo = TRUE)
vec1 <- rnorm(1000, 100, 10)
vec2 <- rnorm(1000, 150,10)
install.packages(c("shinylive", "httpuv"))
vec1 <- c(0.5,0.75,1,1.25,1.5)
vec2 <- c(1,1.5,2,2.5,3)
install.packages('electricShine')
buildPath <- tempdir()
electricShine::electrify(app_name = "My_App",
short_description = "My demo application",
semantic_version = "1.0.0",
build_path = buildPath,
mran_date = NULL,
cran_like_url = "https://cran.r-project.org",
function_name = "run_app",
git_host = "github",
git_repo = "chasemc/demoApp@8426481",
local_package_path = NULL,
package_install_opts = list(type = "binary"),
run_build = TRUE)
library(electricShine)
install.packages("electricShine")
install.packages("electricShine")
shiny::runApp('C:/Programming/Code/Wendy-RA/Working/Pages/Fair_Inequality/myapp')
install.packages("htmltools")
install.packages("htmltools")
shiny::runApp('C:/Programming/Code/Wendy-RA/Working/Pages/Fair_Inequality/myapp')
shiny::runApp('C:/Programming/Code/Wendy-RA/Working/Pages/Fair_Inequality/myapp')
update.packages("htmltools")
runApp('C:/Programming/Code/Wendy-RA/Working/Pages/Fair_Inequality/myapp')
runApp('C:/Programming/Code/Wendy-RA/Working/Pages/Fair_Inequality/myapp')
update.packages("htmltools")
remove.packages("htmltools")
install.packages("htmltools")
library(shiny)
library(comprehenr)
library(tidyverse)
library(EnvStats)
library(ggplot2)
calc_sib_gini <- function(dataframe) {
## Calculate Gini for entire population
# Reshape such that there is only one income column
dataframe_long <- dataframe %>%
pivot_longer(cols = starts_with("Income"),
names_to = "Sibling",
values_to = "Income")
# Within sibling
n = length(dataframe$Income)
mad = sum(abs(dataframe$Income - dataframe$Income_SSS)) / n
rmad = mad / mean(dataframe_long$Income)
gini = 0.5 * rmad * n/(n-1)
return(dataframe_long)
}
# Sibling Gini for each group
calc_sib_groub_gini <- function(dataframe) {
# Setup table
df_gini <- data.frame(matrix(ncol = 3, nrow = 0))
colnames(df_gini) <- c("Group", "Within_SSS", "Total")
# Need long version of data
dataframe_long <- dataframe %>%
pivot_longer(cols = starts_with("Income"),
names_to = "Sibling",
values_to = "Income")
# Aggregates are easy
all_within_SSS_gini = calc_sib_gini(dataframe)
all_total_gini <- calc_total_gini(dataframe_long)
# Fill in the All category
df_gini[nrow(df_gini) + 1,] = list(Group = "All", Within_SSS = all_within_SSS_gini, Total = all_total_gini)
# Iterate over groups
for(group in unique(dataframe$Group)){
# Calculate group Gini and sibling gini
df_group <- df %>% filter(Group == group)
group_gini <- calc_total_gini(df_group)
group_sib_gini <- calc_sib_gini(df_group)
# Add to group
df_gini[nrow(df_gini) + 1,] = list(Group = group, Within_SSS = group_sib_gini, Total = group_gini)
}
return(df_gini)
}
calc_total_gini <- function(dataframe){
# Get incomes
incomes = dataframe$Income
n = length(incomes)
# Need to divide and multiply to divide by the right amount and get the correct mean
mad = sum(as.numeric(dist(incomes))) / (0.5 * n^2)
rmad = mad / mean(incomes)
gini = 0.5 * rmad * n/(n-1)
# Get all possible pairs
return(gini)
}
# Calculates Gini within a given group
calc_group_gini <- function(dataframe){
df_gini <- data.frame(matrix(ncol = 2, nrow = 0))
colnames(df_gini) <- c("Group", "Gini")
# Calculate total Gini and add
total_gini <- calc_total_gini(dataframe)
df_gini[nrow(df_gini) + 1,] = list(Group = "All", Gini = total_gini)
# Iterate over groups
for(group in unique(dataframe$Group)){
# Calculate group Gini
df_group <- df %>% filter(Group == group)
group_gini <- calc_total_gini(df_group)
# Add to group
df_gini[nrow(df_gini) + 1,] = list(Group = group, Gini = group_gini)
}
return(df_gini)
inc_men <- c(1,1,5)
inc_wom <- c(1,1,5)
inc_all <- c(inc_men, inc_wom)
print(inc_all)
inc_men <- c(1,1,5)
inc_wom <- c(1,1,5)
inc_all <- c(inc_men, inc_wom)
print(inc_all)
print(inc_all)
# Testing for it
inc_men <- c(1,1,5)
inc_wom <- c(1,1,5)
inc_all <- c(inc_men, inc_wom)
print(inc_all)
print("test")
print("test")
print("test")
inc_men <- c(1,1,5)
inc_wom <- c(1,1,5)
inc_all <- c(inc_men, inc_wom)
print(inc_all)
calc_total_gini <- function(inc_vector){
print(calc_total_gini(inc_men), calc_total_gini(inc_wom), calc_total_gini(inc_all))
print(calc_total_gini(inc_men), calc_total_gini(inc_wom), calc_total_gini(inc_all))
calc_total_gini <- function(inc_vector){
print(calc_total_gini(inc_men), calc_total_gini(inc_wom), calc_total_gini(inc_all))
print(calc_total_gini(inc_men), calc_total_gini(inc_wom), calc_total_gini(inc_all))
calc_total_gini <- function(inc_vector){
calc_total_gini <- function(inc_vector){
calc_total_gini <- function(inc_vector){
# Get incomes
incomes = inc_vector
n = length(incomes)
# Need to divide and multiply to divide by the right amount and get the correct mean
mad = sum(as.numeric(dist(incomes))) / (0.5 * n^2)
rmad = mad / mean(incomes)
gini = 0.5 * rmad * n/(n-1)
# Get all possible pairs
return(gini)
}
library(shiny)
library(comprehenr)
library(tidyverse)
library(EnvStats)
library(ggplot2)
calc_total_gini <- function(inc_vector){
# Get incomes
incomes = inc_vector
n = length(incomes)
# Need to divide and multiply to divide by the right amount and get the correct mean
mad = sum(as.numeric(dist(incomes))) / (0.5 * n^2)
rmad = mad / mean(incomes)
gini = 0.5 * rmad * n/(n-1)
# Get all possible pairs
return(gini)
}
inc_men <- c(1,1,5)
inc_wom <- c(1,1,5)
inc_all <- c(inc_men, inc_wom)
print(calc_total_gini(inc_men), calc_total_gini(inc_wom), calc_total_gini(inc_all))
calc_total_gini(inc_men)
calc_total_gini(inc_wom)
calc_total_gini(inc_all)
runApp('C:/Programming/Code/Wendy-RA/Working/Pages/Fair_Inequality/myapp')
runApp('C:/Programming/Code/Wendy-RA/Working/Pages/Fair_Inequality/myapp')
runApp('C:/Programming/Code/Wendy-RA/Working/Pages/Fair_Inequality/myapp')
shinylive::export(appdir = "myapp", destdir = "docs")
setwd("C:/Programming/Code/Wendy-RA/Working/Pages/Fair_Inequality")
shinylive::export(appdir = "myapp", destdir = "docs")
runApp('myapp')
calc_total_gini(inc_men)
calc_total_gini(inc_wom)
calc_total_gini(inc_all)
calc_total_gini <- function(inc_vector){
# Get incomes
incomes = inc_vector
n = length(incomes)
# Need to divide and multiply to divide by the right amount and get the correct mean
mad = sum(as.numeric(dist(incomes))) / (0.5 * n^2)
rmad = mad / mean(incomes)
gini = 0.5 * rmad * n/(n-1)
print(mad)
print(mean(incomes))
# Get all possible pairs
return(gini)
}
inc_wom <- c(1,1,5)
inc_all <- c(inc_men, inc_wom)
inc_men <- c(1,1,5)
calc_total_gini(inc_men)
calc_total_gini(inc_wom)
calc_total_gini(inc_all)
inc_all
mean(inc_all)
